# Проверка на простоту

В этой задаче предлагается реализовать функцию, проверяющую число на простоту
```c++
bool IsPrime(uint64_t x);
```

Ее однопоточный вариант можно найти в `is_prime.cpp` --- это простой поиск делителей до корня числа. Используйте тот же алгоритм, но реализуйте его многопоточную версию. Распределите пространство перебора между потоками и объедините результаты.

Сравните время работы однопоточной и многопоточной версии. Во всех ли случаях многопоточная версия быстрее? Обратите внимание, что если какой-то поток уже нашел делитель числа, то остальным нет никакого смысла продолжать перебор. Подумайте, как реализовать алгоритм так, чтобы другие потоки не совершали холостой работы в таких случаях.

Обратите внимание, что это учебная задача --- на практике для проверки на простоту существуют очень эффективные алгоритмы, например [тест Миллера-Рабина](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test).

### Полезные ссылки
* [std::thread](https://en.cppreference.com/w/cpp/thread/thread)
* [std::jthread](https://en.cppreference.com/w/cpp/thread/jthread)
* [std::atomic](https://en.cppreference.com/w/cpp/atomic/atomic)
* [std::atomic_flag](https://en.cppreference.com/w/cpp/atomic/atomic_flag)

### Ограничения на бенчмарки
* `1000000000000000177` - 3 с
* `1000000000375847551` - 3 с
* `1000000016000000063` - 3 с
* `3778117929678325589` - 6 с
