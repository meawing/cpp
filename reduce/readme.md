# Reduce

В этом задании предлагается реализовать левосторонний reduce, т.е. функцию высшего порядка
```math
g(f, initial, a) = f(... f(f(initial, a_1), a_2), a_n)
```

Здесь $`f`$ - некоторая бинарная коммутативная и ассоциативная функция, а $`a`$ - массив длины $`n`$.

Однопоточную версию вы можете найти в `reduce.h`. Пользуясь свойствами функции $`f`$, реализуйте многопоточную версию.

* Сравните скорость работы однопоточной и многопоточной версии для простых функций, вроде сложения или умножения. Быстрее ли многопоточная версия, почему?
* Для сохранения результатов каждого потока вы, вероятно, заведёте вектор, где в $`i`$-ой ячейке будете хранить результат $`i`$-ого потока. Сравните 2 подхода:
  * писать результат в локальную переменную, а в конце обновить $`i`$-ую ячейку
  * сразу писать результат в $`i`$-ую ячейку в процессе вычисления
* Могут ли эти 2 варианта отличаться по времени работы? Почему?

### Полезные ссылки
* [std::thread](https://en.cppreference.com/w/cpp/thread/thread)
* [std::jthread](https://en.cppreference.com/w/cpp/thread/jthread)
* [std::reduce](https://en.cppreference.com/w/cpp/algorithm/reduce)
* [False sharing](https://en.wikipedia.org/wiki/False_sharing)

### Ограничения
* Время выполнения бенчмарка `Multithreading` должно быть менее 110 мс
* Нельзя пользоваться [Execution policy](https://en.cppreference.com/w/cpp/algorithm#Execution_policies)
